--
-- Authors: Julien Lange <j.lange@ic.ac.uk> and
--
--
-- This module contains function to manipute the Petri nets
-- generated by petrify
--

module PetriNet where

import Data.Set as S
import Data.List as L
import Data.Map.Strict as M
import Misc
import Data.String.Utils as SU
-- import Data.List.Utils as SU

data Place = P String
           deriving (Ord, Eq, Show)

data Transition = T String | Silent String
                deriving (Ord, Eq, Show)

data Flow = PT (Place, Transition) 
          | TP (Transition, Place)
          deriving (Ord, Eq, Show)
                     
            
type Net = (Set Place, Set Place, Set Transition, Set Flow)


--
-- TRANSFORMATION NUMBER ONE (One-source NET)
--
oneSource :: Net -> Net
oneSource (pplaces, q0, events, flow) =
  -- if (S.size init ) == 1 then pn
  -- else
    let np = P ("p_init")
        nt = Silent ("t_init")
        addflow = S.insert (PT (np,nt)) (S.map (\x -> TP (nt, x)) q0)
    in 
     (S.insert np pplaces, S.singleton np , S.insert nt events, S.union addflow flow)

isPT :: Flow -> Bool
isPT (PT _) = True
isPT (TP _) = False

isTP :: Flow -> Bool
isTP p = not $ isPT p



--
-- TRANSFORMATION NUMBER TWO (Joined NET)
--
preSet :: Net -> Place -> Set Transition
preSet (_, _, _, flow) p =
  S.map (\(TP (t,_)) -> t) (S.filter (\(TP (_,p')) -> p == p')  (S.filter (\f -> isTP f) flow))
  
  
postSet :: Net -> Place -> Set Transition
postSet (_, _, _, flow) p =
  S.map (\(PT (_,t)) -> t) (S.filter (\(PT (p',_)) -> p == p')  (S.filter (\f -> isPT f) flow))
  
  
preSetTrans :: Net -> Transition -> Set Place
preSetTrans (_, _, _, flow) t =
  S.map (\(PT (p,_)) -> p) (S.filter (\(PT (_,t')) -> t == t')  (S.filter (\f -> isPT f) flow))
  
  
postSetTrans :: Net -> Transition -> Set Place
postSetTrans (_, _, _, flow) t =
  S.map (\(TP (_,p)) -> p) (S.filter (\(TP (t',_)) -> t == t')  (S.filter (\f -> isTP f) flow))
  
  
  
prepostTable :: Net -> (Place -> Set Transition) -> Map (Set Transition) (Set Place)
prepostTable (pplaces, _, _, _) f = helper M.empty (S.toList pplaces)
  where helper mapping (p:ps) =
          let 
            preset = f p
          in
          case M.lookup preset mapping of
            Just pset -> helper (M.insert preset (S.insert p pset) mapping) ps
            Nothing -> helper (M.insert preset (S.singleton p) mapping) ps
        helper m [] = m

presetTable :: Net -> Map (Set Transition) (Set Place)
presetTable pn = prepostTable pn (preSet pn)

postsetTable :: Net -> Map (Set Transition) (Set Place)
postsetTable pn = prepostTable pn (postSet pn)


joinPred :: Net -> Net
joinPred pn = helper 0 (M.toAscList (presetTable pn)) pn
  where helper i ((k,ps):mps) net@(pplaces, q0, events, flow) = 
          if (S.size k) < 2 || (S.size ps) < 2
          then helper (i+1) mps net
          else 
            let np = P ("PJPRE"++(show i))
                nt = Silent ("TJPRE"++(show i))
                toadd = S.insert (PT (np,nt)) 
                        $ S.union  (S.map (\x -> TP(x,np)) k) (S.map (\x -> TP(nt,x)) ps)
                toremove = S.map (\(x,y) -> TP(x,y)) 
                           (S.fold S.union S.empty (S.map (\x -> cartProd k (S.singleton x)) ps))
                npn = (S.insert np pplaces, q0, S.insert nt events, S.difference (S.union flow toadd) (toremove))
            in helper (i+1) mps npn
        helper _ [] net = net


joinPost :: Net -> Net
joinPost pn = helper 0 (M.toAscList (postsetTable pn)) pn
  where helper i ((k,ps):mps) net@(pplaces, q0, events, flow) = 
          if (S.size k) < 2  || (S.size ps) < 2
          then helper (i+1) mps net
          else 
            let np = P ("PJPOST"++(show i))
                nt = Silent ("TJPOST"++(show i))
                toadd = S.insert (TP (nt,np)) 
                        $ S.union  (S.map (\x -> PT(np,x)) k) (S.map (\x -> PT(x,nt)) ps)
                toremove = S.map (\(x,y) -> PT(x,y)) 
                           (S.fold S.union S.empty (S.map (\x -> cartProd (S.singleton x) k) ps))
                npn = (S.insert np pplaces, q0, S.insert nt events, S.difference (S.union flow toadd) (toremove))
            in helper (i+1) mps npn
        helper _ [] net = net


printTables :: Net -> IO()
printTables pn = do putStrLn "TABLES:"
                    putStrLn (show $ presetTable pn)
                    putStrLn (show $ postsetTable pn)

--
-- Parsing Functions
--
parsePetriNet :: [[String]] -> Net
parsePetriNet content = helper (S.empty, S.empty, S.empty, S.empty) content
  where
    helper pn (y:ys) = let pn' = helperLine pn y
                       in helper pn' ys
    helper pn [] = pn
    helperLine pn@(pplaces , q0, transs, flows) (x:xs) =
          case x of 
            ".outputs" -> let  transs' = L.foldr (S.insert) S.empty (L.map (\t -> (T t)) xs)
                          in (pplaces, q0, transs',  flows)
            ".state" -> pn
            ".marking" -> (pplaces, parseMarkedPlaces xs, transs,  flows)
            "#" -> pn
            ".model" -> pn
            ".end" -> let new_trans = getTransitions flows
                      in (nplaces, q0, new_trans,  flows)
              where nplaces = S.map getPlace flows
            y -> let nflow = parseFlow transs y xs
                 in (pplaces, q0, transs, S.union nflow flows)
    helperLine pn [] = pn


getTransitions :: Set Flow -> Set Transition
getTransitions flow = helper S.empty (S.toList flow)
  where helper acc ((PT(_,t)):xs) = helper (S.insert t acc) xs
        helper acc ((TP(t,_)):xs) = helper (S.insert t acc) xs
        helper acc [] = acc

getPlace :: Flow -> Place
getPlace (PT (p,_)) = p
getPlace (TP (_,p)) = p

-- INPUT: "{", "p5", "p6",.... "}"
parseMarkedPlaces :: [String] -> Set Place
parseMarkedPlaces (x:xs) =
  case x of "{" -> parseMarkedPlaces xs
            "}" -> S.empty
            s -> S.insert (P s) (parseMarkedPlaces xs)
parseMarkedPlaces [] = S.empty

isTrans :: String -> Set Transition -> Bool
isTrans str transs = S.member (T (removeTranSplit str)) transs

removeTranSplit :: String -> String
removeTranSplit s = let sp = SU.split "/" s in
  if (L.length sp) == 2
  then (sp!!0)
  else s


-- "p5", "alice0,bob0,0->1:bwin", "alice0,carol0,0->2:cwin" ---> { (p5,alice0,bob0,0->1:bwin) , (p5,alice0,carol0,0->2:cwin) }
parseFlow :: Set Transition -> String -> [String] -> Set Flow
parseFlow transs srcnode xs = S.fromList (L.map (\x -> consFlow srcnode x) xs)
  where consFlow s x = if isTrans x transs 
                       then PT (P s, T x) 
                       else TP (T s, P x)
--
-- Printing Functions
--          
printPlace :: Place -> String
printPlace (P s) = "P"++s

printTransition :: Transition -> String
printTransition t =  case labelTrans t of
  Just s -> removeTranSplit s
  Nothing -> "s"

printTransitionId :: Transition -> String
printTransitionId (T t) = "T"++((SU.replace "/" "") . (SU.replace ":" "") . (SU.replace "->" "") .(SU.replace "," "")) t
printTransitionId (Silent t) = "T"++t

labelTrans :: Transition -> Maybe String
labelTrans (T t) = 
  let sp = SU.split "," t in
    if (L.length sp) == 3 
    then Just (sp!!2)
    else Nothing
labelTrans (Silent _) = Nothing
                    

printFlow :: Flow -> String
printFlow (PT (p,t)) = (printPlace p)++" -> "++(printTransitionId t)++"; \n"
printFlow (TP (t,p)) = (printTransitionId t)++" -> "++(printPlace p)++"; \n"

printNet :: Net -> String
printNet (pplaces , _, transs, flows) =
  let header =  "digraph PN { \n"
      footer = "}\n"
      node_places = S.fold (++) "" $ S.map (\x -> (printPlace x)++" [label=\""++(printPlace x)++"\"]; \n ") pplaces
      node_trans = S.fold (++) "" $ S.map (\x -> (printTransitionId x)++" [label=\""++(printTransition x)++"\"]; \n ") transs
      st_flow =  S.fold (++) "" (S.map printFlow flows)
  in
   header++node_places++node_trans++st_flow++footer
                
